---

# 59. 螺旋矩阵 II —— 题解

### 1. 题目逻辑分析

本题属于**模拟类**题目。核心任务是按照“顺时针螺旋”的顺序填满一个 $n \times n$ 的方阵。

解决这类问题的最高效、最直观的方法是 **“边界收缩法”**。
我们想象矩阵有四面墙：`上(top)`、`下(bottom)`、`左(left)`、`右(right)`。
*   每填完**一行**，对应的水平边界就向内缩进。
*   每填完**一列**，对应的垂直边界就向内缩进。

当填入的数字达到 $n^2$ 时，所有格子正好被填满。

---

### 2. 解题步骤图解

假设 $n = 3$，初始边界为：`top=0, bottom=2, left=0, right=2`

1.  **从左到右**填充 `top` 行：填入 1, 2, 3。填完后，第一行废弃，`top++` (变为 1)。
2.  **从上到下**填充 `right` 列：填入 4, 5。填完后，最后一列废弃，`right--` (变为 1)。
3.  **从右到左**填充 `bottom` 行：填入 6, 7。填完后，最后一行废弃，`bottom--` (变为 1)。
4.  **从下到上**填充 `left` 列：填入 8。填完后，第一列废弃，`left++` (变为 1)。
5.  **重复循环**：最后填入 9，完成。

---

### 3. Java 实现

Java 版代码注重结构严谨，通过 `while` 循环和四个 `for` 循环精确控制方向。

```java
import java.util.Arrays;

public class Solution {
    public int[][] generateMatrix(int n) {
        // 1. 初始化结果矩阵
        int[][] matrix = new int[n][n];
        
        // 2. 定义四个边界
        int top = 0, bottom = n - 1;
        int left = 0, right = n - 1;
        
        int cur = 1;      // 当前要填入的数字
        int target = n * n; // 目标终止数字

        while (cur <= target) {
            // 步骤 A: 从左向右填充顶行
            for (int i = left; i <= right; i++) {
                matrix[top][i] = cur++;
            }
            top++; // 填充完后，上边界下移

            // 步骤 B: 从上向下填充右列
            for (int i = top; i <= bottom; i++) {
                matrix[i][right] = cur++;
            }
            right--; // 填充完后，右边界左移

            // 步骤 C: 从右向左填充底行
            // 注意：因为是正方形且正好填满，cur <= target 隐含了边界检查
            for (int i = right; i >= left; i--) {
                matrix[bottom][i] = cur++;
            }
            bottom--; // 填充完后，下边界上移

            // 步骤 D: 从下向上填充左列
            for (int i = bottom; i >= top; i--) {
                matrix[i][left] = cur++;
            }
            left++; // 填充完后，左边界右移
        }
        return matrix;
    }

    // --- 测试用例 ---
    public static void main(String[] args) {
        Solution sol = new Solution();
        int n = 3;
        int[][] res = sol.generateMatrix(n);
        System.out.println("n = " + n + " 的螺旋矩阵：");
        for (int[] row : res) {
            System.out.println(Arrays.toString(row));
        }
    }
}
```

---

### 4. Python 实现

Python 版代码更加简洁，利用 `range` 的步长控制（如 `-1`）可以轻松实现反向遍历。

```python
class Solution:
    def generateMatrix(self, n: int) -> list[list[int]]:
        # 1. 初始化 n x n 矩阵
        matrix = [[0] * n for _ in range(n)]
        
        # 2. 定义四个边界和初始数字
        top, bottom = 0, n - 1
        left, right = 0, n - 1
        cur, target = 1, n * n
        
        while cur <= target:
            # 步骤 A: 从左向右 (行不变，列从 left 到 right)
            for i in range(left, right + 1):
                matrix[top][i] = cur
                cur += 1
            top += 1
            
            # 步骤 B: 从上向下 (列不变，行从 top 到 bottom)
            for i in range(top, bottom + 1):
                matrix[i][right] = cur
                cur += 1
            right -= 1
            
            # 步骤 C: 从右向左 (行不变，列从 right 到 left)
            # range(start, stop, step) 包含 start 不包含 stop
            for i in range(right, left - 1, -1):
                matrix[bottom][i] = cur
                cur += 1
            bottom -= 1
            
            # 步骤 D: 从下向上 (列不变，行从 bottom 到 top)
            for i in range(bottom, top - 1, -1):
                matrix[i][left] = cur
                cur += 1
            left += 1
            
        return matrix

# --- 测试用例 ---
if __name__ == "__main__":
    sol = Solution()
    n_val = 3
    print(f"n = {n_val} 的螺旋矩阵：")
    for row in sol.generateMatrix(n_val):
        print(row)
```

---

### 5. 复杂度分析

*   **时间复杂度：$O(n^2)$**
    *   我们需要填满矩阵中的每一个格子，总共 $n \times n$ 个。每个单元格只被访问并赋值一次，因此时间复杂度与矩阵大小成线性关系。
*   **空间复杂度：$O(1)$** (不考虑存储结果矩阵的开销)
    *   除了用于存储结果的二维数组外，我们只使用了 `top, bottom, left, right, cur, target` 这几个变量，它们占用的空间不随 `n` 的增大而增长。

