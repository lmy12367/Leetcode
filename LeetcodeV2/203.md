------

# 题目：移除链表元素 (Remove Linked List Elements)

### 1. 核心思路：虚拟头节点 (Dummy Head)

**痛点：**

通常删除链表节点的操作是“找到前一个节点，把它的指针指向下下个节点”。

但是，如果**头节点 (Head)** 本身就是要删除的元素，它前面没有节点，这就导致需要单独写一段逻辑来处理头节点。

**解决方案：**

我们人为地在 `head` 之前加一个 **虚拟头节点 (dummy)**。

- 这样链表中所有的节点（包括原来的 head）都有了“前驱节点”。
- 我们就可以用**统一的逻辑**来处理所有节点的删除操作。
- 最后返回 `dummy.next` 即可。

### 2. 算法流程

1. 创建一个 `dummy` 节点，将其 `next` 指向 `head`。
2. 定义一个指针 `curr` 指向 `dummy`。
3. 遍历链表：
   - 如果 `curr.next` 的值等于 `val`：**删除它**（`curr.next = curr.next.next`）。**注意：** 此时不要移动 `curr`，因为新的 `next` 还需要检查。
   - 如果 `curr.next` 的值不等于 `val`：**保留它**，`curr` 向后移动（`curr = curr.next`）。
4. 遍历结束，返回 `dummy.next`。

------

### 3. Java 代码实现

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        // 1. 创建虚拟头节点 (值设为 -1 或 0 都可以，不影响结果)
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        
        // 2. 定义扫描指针，从虚拟头开始
        ListNode curr = dummy;
        
        // 3. 遍历链表
        // 注意：我们要判断的是 curr.next，所以循环条件是 curr.next != null
        while (curr.next != null) {
            
            if (curr.next.val == val) {
                // 【核心删除逻辑】
                // 发现目标值，直接“跨过”这个节点
                curr.next = curr.next.next;
                // 重点：这里不要写 curr = curr.next;
                // 因为删除了一个节点后，后面的节点补位上来，下一次循环要检查这个新补上来的节点
            } else {
                // 如果不是目标值，指针才正常后移
                curr = curr.next;
            }
        }
        
        // 4. 返回真正的头节点（虚拟头节点的下一个）
        return dummy.next;
    }
}
```



------

### 4. Python 代码实现

Python 的逻辑完全一致，语法更加简洁。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        # 1. 创建虚拟头节点
        # Python 中可以直接在构造函数里指定 next
        dummy = ListNode(val=-1, next=head)
        
        # 2. 定义指针
        curr = dummy
        
        # 3. 循环遍历
        while curr.next:
            if curr.next.val == val:
                # 【核心删除逻辑】
                # 跳过 curr.next，指向下下个节点
                curr.next = curr.next.next
                # 同样，这里不移动 curr，继续检查新的 next
            else:
                # 只有确认保留该节点时，才移动指针
                curr = curr.next
                
        # 4. 返回结果
        return dummy.next
```



------

### 5. 复杂度分析

- **时间复杂度 (Time Complexity): $O(N)$**
  - 其中 $N$ 是链表的长度。我们只需要遍历链表一次。
- **空间复杂度 (Space Complexity): $O(1)$**
  - 我们只使用了 `dummy` 和 `curr` 两个额外的指针，没有使用额外的数组或数据结构，所以是常数级空间。

### 6. 易错点总结 (Debug 指南)

1. **忘记处理 `else`：**
   - 错误写法：不管删没删，都执行 `curr = curr.next`。
   - 后果：如果是连续两个要删除的节点（如 `[1, 2, 6, 6, 3]`, 删 `6`），会导致第二个 `6` 被跳过检查，从而漏删。
2. **返回了 `head` 而不是 `dummy.next`：**
   - 后果：如果原本的头节点被删除了，返回 `head` 就会指向一个错误的、已经被剔除的节点，或者空指针。
3. **空指针异常：**
   - 一定要保证 `while` 循环条件是 `curr.next != null`，防止访问空引用的 `val` 属性。