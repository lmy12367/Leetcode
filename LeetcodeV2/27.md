这篇题解将为你详细解析力扣第 27 题“移除元素”的解题思路、代码实现及复杂度分析。

---

# LeetCode 27. 移除元素 (Remove Element)

### 1. 题目描述
给你一个数组 `nums` 和一个值 `val`，你需要 **原地（In-place）** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

**注意：**
- 不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并 **原地修改输入数组**。
- 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

---

### 2. 解题思路：双指针法（快慢指针）

由于题目要求“原地修改”且不能使用额外数组，最经典且高效的方法就是使用**双指针**。

#### 核心角色设定：
- **快指针 (`fast`)**：充当“侦察兵”。它从头到尾遍历数组，负责寻找那些**不等于** `val` 的元素（即我们需要保留的“宝贝”）。
- **慢指针 (`slow`)**：充当“搬运工”。它记录下一个“宝贝”应该存放的位置。

#### 算法步骤：
1. 初始化 `slow = 0`。
2. 开始循环，让 `fast` 从 `0` 遍历到数组末尾：
   - 如果 `nums[fast]` **不等于** `val`：
     - 说明找到了一个需要保留的元素。
     - 将 `nums[fast]` 复制到 `nums[slow]` 的位置。
     - `slow` 向后移动一位，准备接收下一个元素。
   - 如果 `nums[fast]` **等于** `val`：
     - 直接跳过，不进行任何操作（相当于丢弃了这个元素）。
3. 循环结束，`slow` 的值即为新数组的长度。

---

### 3. 代码实现

#### Java 版本
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // slow 记录下一个有效元素存放的位置
        int slow = 0;
        
        // fast 遍历整个数组
        for (int fast = 0; fast < nums.length; fast++) {
            // 如果发现当前元素不是要删除的值
            if (nums[fast] != val) {
                // 将有效元素搬运到 slow 指向的位置
                nums[slow] = nums[fast];
                // 慢指针向前移动
                slow++;
            }
        }
        
        // 返回有效元素的个数
        return slow;
    }
}
```

#### Python 版本
```python
from typing import List

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # slow 记录下一个非 val 元素该存放的位置
        slow = 0
        
        # 使用 fast 指针遍历数组
        for fast in range(len(nums)):
            # 如果当前元素不是 val
            if nums[fast] != val:
                # 把元素覆盖到 slow 位置
                nums[slow] = nums[fast]
                # slow 向后移动
                slow += 1
                
        # slow 即为新数组的长度
        return slow
```

---

### 4. 复杂度分析

*   **时间复杂度**：$O(n)$
    *   其中 $n$ 是数组的长度。快指针 `fast` 只需要从头到尾完整遍历一次数组即可。
*   **空间复杂度**：$O(1)$
    *   我们只使用了 `slow` 和 `fast` 两个整型变量，没有申请额外的数组空间，符合题目“原地修改”的要求。

---

### 5. 图解示例
假设 `nums = [3, 2, 2, 3]`, `val = 3`：

1.  **开始**：`slow=0`, `fast=0`。`nums[0]` 是 3，等于 `val`，跳过。
2.  **下一步**：`slow=0`, `fast=1`。`nums[1]` 是 2，不等于 `val`。
    - 搬运：`nums[0] = nums[1]` -> 数组变为 `[2, 2, 2, 3]`
    - `slow` 变为 1。
3.  **下一步**：`slow=1`, `fast=2`。`nums[2]` 是 2，不等于 `val`。
    - 搬运：`nums[1] = nums[2]` -> 数组变为 `[2, 2, 2, 3]`
    - `slow` 变为 2。
4.  **下一步**：`slow=2`, `fast=3`。`nums[3]` 是 3，等于 `val`，跳过。
5.  **结束**：遍历完成，返回 `slow = 2`。前两个元素 `[2, 2]` 正是结果。

---

### 总结
双指针法是解决数组原地修改问题的“万能钥匙”。在这道题中，快指针负责“筛查”，慢指针负责“重新填表”，通过覆盖旧数据巧妙地实现了删除操作。