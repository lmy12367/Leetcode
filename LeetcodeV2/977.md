这是一个为你整理好的完整题解，采用 Markdown 格式编写，你可以直接复制到你的笔记、博客或者 GitHub 中。

---

# LeetCode 977. 有序数组的平方 - 题解

### 1. 题目描述
给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

*   **示例 1**：输入 `nums = [-4, -1, 0, 3, 10]` 输出 `[0, 1, 9, 16, 100]`
*   **示例 2**：输入 `nums = [-7, -3, 2, 3, 11]` 输出 `[4, 9, 9, 49, 121]`

---

### 2. 核心思路：双指针法（Optimal Solution）
由于数组已经是有序的，虽然包含负数，但其平方后的分布规律非常明显：
*   **最大值**：一定出现在原数组的 **最左端**（负值最大）或 **最右端**（正值最大）。
*   **最小值**：越靠近 0 的数平方越小，通常在数组中间。

因此，我们可以使用两个指针从两端向中间推进，每次选出较大的平方值，**倒序**填入结果数组。

**算法步骤：**
1.  定义左指针 `left = 0`，右指针 `right = n - 1`。
2.  创建一个等长的新数组 `result`。
3.  定义一个位置指针 `pos`，初始指向结果数组的 **末尾**。
4.  比较 `nums[left]` 和 `nums[right]` 的平方：
    *   如果左边平方大：将左边平方存入 `result[pos]`，`left` 向右移。
    *   如果右边平方大（或相等）：将右边平方存入 `result[pos]`，`right` 向左移。
5.  每填入一个数，`pos` 向前移动一位，直到 `left > right`。

---

### 3. 复杂度分析
*   **时间复杂度**：$O(n)$。我们只需遍历一次原数组。
*   **空间复杂度**：$O(n)$。需要额外创建一个结果数组（如果不计入返回结果的空间，则为 $O(1)$）。

---

### 4. 代码实现

#### Java 版本
```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        
        int left = 0;
        int right = n - 1;
        int pos = n - 1; // 从后往前填充

        while (left <= right) {
            int leftSquare = nums[left] * nums[left];
            int rightSquare = nums[right] * nums[right];

            if (leftSquare > rightSquare) {
                result[pos] = leftSquare;
                left++;
            } else {
                result[pos] = rightSquare;
                right--;
            }
            pos--;
        }
        return result;
    }
}
```

#### Python 版本
```python
class Solution:
    def sortedSquares(self, nums: list[int]) -> list[int]:
        n = len(nums)
        # 初始化全为 0 的结果数组
        res = [0] * n
        
        left, right = 0, n - 1
        pos = n - 1  # 填充指针
        
        while left <= right:
            # 计算两端的平方值
            l_val = nums[left] ** 2
            r_val = nums[right] ** 2
            
            if l_val > r_val:
                res[pos] = l_val
                left += 1
            else:
                res[pos] = r_val
                right -= 1
            
            pos -= 1 # 结果下标向前移
            
        return res
```

---

### 5. 总结
*   **关键点**：意识到最大的平方值一定在两端。
*   **注意点**：一定要从结果数组的**末尾**开始填充，否则无法利用原数组的有序性。
*   **进阶要求**：该双指针算法完美符合 $O(n)$ 的时间复杂度要求。