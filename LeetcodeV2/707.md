------

### 核心思想 (Cheat Sheet)

1. **虚拟头节点 (Dummy Head)**:
   - 我们在真正的链表头前面加一个假的节点 `dummy`。
   - **好处**：这让“在头部插入/删除”和“在中间插入/删除”的逻辑完全一样，不需要写额外的 `if (index == 0)` 判断。
2. **定位技巧**:
   - 记号：`pred` 是目标位置的前一个节点（前驱）。
   - **从 `dummy` 开始出发**：
     - 如果我们要操作 `index` 位置（插入或删除），我们需要找到它的前驱。
     - **口诀**：从 `dummy` 往后走 `index` 步，就刚好停在 `index` 的前驱节点上。
3. **时间复杂度**:
   - `addAtHead`: O(1)
   - `get`, `addAtIndex`, `deleteAtIndex`: O(k)，k 是索引位置（需要遍历找到位置）。

------

### 1. Java 完整代码

可以直接复制到 LeetCode 的 Java 编辑区提交。

Java

```
class MyLinkedList {
    // 定义链表节点结构
    class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    int size;          // 存储链表长度
    ListNode dummyHead; // 虚拟头节点

    // 初始化
    public MyLinkedList() {
        size = 0;
        dummyHead = new ListNode(0); // 这里的 0 没有任何意义，只是占位
    }
    
    // 获取第 index 个节点的值
    public int get(int index) {
        // 1. 检查索引是否有效
        if (index < 0 || index >= size) {
            return -1;
        }
        
        // 2. 从 dummyHead 开始查找
        ListNode cur = dummyHead;
        // 因为 dummyHead 是 -1 号位置，所以我们要走 index + 1 步才能到 index 号位置
        for (int i = 0; i <= index; i++) {
            cur = cur.next;
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    // 核心逻辑：在第 index 个节点前插入
    public void addAtIndex(int index, int val) {
        // 1. 处理边界
        if (index > size) return; // 超过长度，无法插入
        if (index < 0) index = 0; // 负索引，插在头部
        
        size++; // 记得更新长度
        
        // 2. 找到前驱节点 (pred)
        ListNode pred = dummyHead;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        
        // 3. 经典的插入“三部曲”
        ListNode toAdd = new ListNode(val);
        toAdd.next = pred.next;
        pred.next = toAdd;
    }
    
    // 删除第 index 个节点
    public void deleteAtIndex(int index) {
        // 1. 检查索引是否有效
        if (index < 0 || index >= size) {
            return;
        }
        
        size--; // 记得更新长度
        
        // 2. 找到前驱节点 (pred)
        ListNode pred = dummyHead;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        
        // 3. 删除操作：跳过目标节点
        pred.next = pred.next.next;
    }
}
```

------

### 2. Python 完整代码

可以直接复制到 LeetCode 的 Python3 编辑区提交。

Python

```
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class MyLinkedList:

    def __init__(self):
        self.size = 0
        self.dummy_head = ListNode(0) # 虚拟头节点

    def get(self, index: int) -> int:
        # 1. 检查索引有效性
        if index < 0 or index >= self.size:
            return -1
        
        # 2. 从 dummy 开始找
        # 我们需要找 index 位置，也就是从 dummy 走 index + 1 步
        curr = self.dummy_head
        for _ in range(index + 1):
            curr = curr.next
        return curr.val

    def addAtHead(self, val: int) -> None:
        self.addAtIndex(0, val)

    def addAtTail(self, val: int) -> None:
        self.addAtIndex(self.size, val)

    def addAtIndex(self, index: int, val: int) -> None:
        # 1. 边界处理
        if index > self.size:
            return
        if index < 0:
            index = 0
        
        self.size += 1
        
        # 2. 找前驱节点 (Predecessor)
        # 从 dummy 走 index 步，刚好停在目标位置的前一个节点
        pred = self.dummy_head
        for _ in range(index):
            pred = pred.next
            
        # 3. 插入操作
        to_add = ListNode(val)
        to_add.next = pred.next
        pred.next = to_add

    def deleteAtIndex(self, index: int) -> None:
        # 1. 边界处理
        if index < 0 or index >= self.size:
            return
        
        self.size -= 1
        
        # 2. 找前驱节点
        pred = self.dummy_head
        for _ in range(index):
            pred = pred.next
            
        # 3. 删除操作
        pred.next = pred.next.next
```

